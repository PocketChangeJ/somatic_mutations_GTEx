require("R6")
require("NMF")
##-------------------------------------------
## CLASSES

NMF <- R6Class(classname = "NMF", 
               public = list(
                             
                             # Instances
                             mutationMat = matrix(),
                             rowsFullZeros = logical(),
                             W = matrix(),
                             H = matrix(),
                             nRuns = integer(),
                             nSign = integer(),
                             nCores = integer(),
                             
                             # Methods
                             initialize = function(mutationMat, normilizingVector = NULL, useFreq = T, nRuns = 30, nSign = 2, nCores = 1) {
                                 
                                 if(is.null(rownames(mutationMat)))
                                    stop("Matrix has to have define row names")
                                 
                                 if(!is.null(normilizingVector)){
                                     stopifnot(nrow(mutationMat) == length(normilizingVector))
                                     mutationMat <- self$normilizeByCol(mutationMat, normilizingVector)
                                 }
                                 
                                 if(useFreq) {
                                     mutationMat <- self$getFrequencyByCol(mutationMat)
                                 }
                                 
                                 self$rowsFullZeros <- rowSums(mutationMat) == 0
                                 self$mutationMat  <- mutationMat
                                 self$nRuns <- nRuns
                                 self$nSign <- nSign
                                 self$nCores <- nCores
                             },
                             
                             nmf = function() {
                                 nmfResult <- nmf(self$mutationMat[!self$rowsFullZeros,], nrun = self$nRuns, rank = self$nSign, .opt = paste0("vp", self$nCores))
                                 
                                 W <- basis(nmfResult)
                                 
                                 # Append rows full of zeros
                                 W <- rbind(W, matrix(0, nrow = sum(self$rowsFullZeros), ncol = ncol(W), dimnames = list(rownames(self$mutationMat)[self$rowsFullZeros], colnames(W))))
                                 W <- W[rownames(self$mutationMat), ]
                                 
                                 self$W <- W
                                 self$H <- coef(nmfResult)
                                 
                                 
                             },
                             
                             normilizeByCol = function(x, y) {
                                 return (x/y)
                             },
                                 
                             getFrequencyByCol = function(x) {
                                 mutaitonMat <- t(t(x) / (colSums(x)))
                             }
                             )
               )

# Contains a list of NMF objects each generated by a MonteCarlo permuted sampling
# in addition several other values are stored too

NMFmontecarloList <- R6Class(classname = "NMFmontecarloList",
                          public = list(
                                        #Instances
                                        mutationMat = matrix(),
                                        mutationMatReduced = matrix(), # store mutation mat minus rows that contribute to <= 1% of info
                                        predictedMutationMatReduced = matrix(),
                                        permutedMat = matrix(), # Stores the las montecarlo permuted matrix
                                        normalizingVector = vector(),
                                        NMFlist = list(),
                                        useFreq = logical(),
                                        nRuns = integer(),
                                        nSign = integer(),
                                        nCores = integer(),
                                        Wall = matrix(),
                                        Hall = matrix(),
                                        Waverage = matrix(),
                                        Haverage = matrix(),
                                        initialized = F, # Flag of when the object has been initialized
                                        clustered = F, # Flag to see if Wall has been clustered, reset when runNMF() is applied
                                        clusterSignatures = vector(),
                                        signatureSimilarities = vector(),
                                        
                                        # Methods
                                        initialize = function(mutationMat, normalizingVector = NULL, useFreq = T, reducedPercentage = 0.01, nRuns = 30, nSign = 2, nCores = 1) {
                                            self$mutationMat  <- mutationMat
                                            self$mutationMatReduced <- self$reduceDimensionalityByRow(mutationMat, reducedPercentage)
                                                
                                            self$nRuns <- nRuns
                                            self$nSign <- nSign
                                            self$useFreq <- useFreq
                                            self$normalizingVector <- normalizingVector
                                            self$nCores <- nCores
                                            
                                            # Reduce dimensionality of matrix
                                            # reduceDimMat()
                                            
                                            
                                            self$runNMF()
                                            self$initialized <- TRUE
                                            
                                        },
                                        
                                        c = function(x) {
                                            
                                            # Append the Wall and Hall matrices from a different NMFmontecarloList object
                                            
                                            # Check for object compatibilities
                                            stopifnot(dim(self$mutationMat) == dim(x$mutationMat))
                                            stopifnot(dim(self$mutationMatReduced) == dim(x$mutationMatReduced))
                                            stopifnot(length(self$normalizingVector) == length(x$normalizingVector))
                                            stopifnot(self$nSign == x$nSign)
                                            
                                            self$Wall <- cbind(self$Wall, x$Wall)
                                            self$Hall <- rbind(self$Hall, x$Hall)
                                            
                                            clustered <- F
                                            
                                        },
                                        
                                        reduceDimensionalityByRow = function(x, percentage = 0.01) {
                                            # Eliminates the maximum number of rows contribuiting to 1% of data
                                            x <- as.matrix(x)
                                            total <- sum(as.matrix(x))
                                            rowTotalPercentage <- rowSums(x) / total
                                            names(rowTotalPercentage) <- rownames(x)
                                            
                                            rowTotalPercentage <- sort(rowTotalPercentage)
                                            rowsToEliminate <- names(rowTotalPercentage) [cumsum(rowTotalPercentage) <= percentage]
                                            
                                            x <- x[! rownames(x) %in% rowsToEliminate, ]
                                            
                                            return(x)
                                            
                                        },
                                        
                                        runNMF = function() {
                                            
                                            # Runs NMF once on a simulated matrix and appends the results to the NMFlist object
                                            
                                            self$permutedMat <- self$simulateMatrix(x = self$mutationMatReduced, 2)
                                            nmfObject <- NMF$new(self$permutedMat, self$normilizingVector, self$useFreq, self$nRuns, self$nSign, self$nCores)
                                            nmfObject$nmf()
                                            
                                            # Appends results to list
                                            self$NMFlist <- c(self$NMFlist, list(nmfObject))
                                            
                                            # Appends M and H matrices
                                            if (!self$initialized) {
                                                self$Wall <- nmfObject$W
                                                self$Hall <- nmfObject$H
                                            } else {
                                                self$Wall <- cbind(self$Wall, nmfObject$W)
                                                self$Hall <- rbind(self$Hall, nmfObject$H)
                                            }
                                            
                                            self$clustered = F
                                        },
                                        
                                        
                                        simulateVector = function(x) {
                                            
                                            # Montecarlo simulation of a vector of counts
                                            # probability of each element is based on it's frequency (i.e. count/sum of all)
                                            
                                            result <-  rep(0, length(x))
                                            x <- sample(1:length(x), sum(x), T, x/sum(x))
                                            x <- table(x)
                                            result[as.numeric(names(x))] <- as.vector(x)
                                            return(result)
                                        },
                                        
                                        simulateMatrix = function(x, MARGIN) {
                                            
                                            # Margin 1 for conserving counts in rows, 2 for 
                                            # conserving counts in columns
                                            rownamesX <- rownames(x)
                                            colnamesX <- colnames(x)
                                            
                                            x <- apply(x, MARGIN, self$simulateVector)
                                            if (MARGIN == 1)
                                                x <- t(x)
                                            
                                            rownames(x) <- rownamesX
                                            colnames(x) <- colnamesX
                                            return(x)
                                        }, 
                                        
                                        applyClusterSignatures = function() {
                                            
                                            # groups similar clusters from the compilation of W
                                            
                                            if (self$clustered)
                                                return()
                                            
                                            self$clusterSignatures <- kmeans(t(self$Wall), self$nSign)$cluster
                                            self$clustered <- TRUE
                                        },
                                        
                                        computeAverageW = function(orderedBySimilarity = T) {
                                            if (!self$clustered) {
                                                self$applyClusterSignatures()
                                                self$calculateSimilarityPerSignature()
                                            }
                                            
                                            result <- matrix(0, nrow = nrow(self$Wall), ncol = self$nSign)
                                            rownames(result) <- rownames(self$Wall)
                                            
                                            signatures <- unique(self$clusterSignatures)
                                            
                                            if(orderedBySimilarity)
                                                signatures <- signatures[order(self$signatureSimilarities, decreasing = T)]
                                            
                                            for (i in 1:length(signatures)) {
                                                columns <- self$clusterSignatures == signatures[i]
                                                result[,i] <- rowMeans(self$Wall[,columns])
                                            }
                                            
                                            self$Waverage <- result
                                            
                                        },
                                        
                                        computeAverageH = function(orderedBySimilarity = T) {
                                            if (!self$clustered) {
                                                self$applyClusterSignatures()
                                                self$calculateSimilarityPerSignature()
                                            }
                                            
                                            result <- matrix(0, nrow = self$nSign, ncol = ncol(self$Hall))
                                            colnames(result) <- colnames(self$Hall)
                                            
                                            signatures <- unique(self$clusterSignatures)
                                            
                                            if(orderedBySimilarity)
                                                signatures <- signatures[order(self$signatureSimilarities, decreasing = T)]
                                            
                                            for (i in 1:length(signatures)) {
                                                rows <- self$clusterSignatures == signatures[i]
                                                result[i,] <- colMeans(self$Hall[rows,])
                                            }
                                            
                                            self$Haverage <- result
                                        },
                                        
                                        calculateSimilarityPerSignature = function() {
                                            
                                            if (!self$clustered)
                                                self$applyClusterSignatures()
                                            
                                            signatures <- unique(self$clusterSignatures)
                                            similarities <- rep(0, length(signatures))
                                            
                                            for(s in 1:length(signatures)) {
                                                
                                                signature <- signatures[s]
                                                currentMat <- self$Wall[,self$clusterSignatures == signature]
                                                currentSimilarity <- vector()
                                                
                                                for(i in 1:(ncol(currentMat) - 1) ) {
                                                    for(j in (i+1):ncol(currentMat)) {
                                                        currentSimilarity <- c(currentSimilarity, self$cosineSimilarity(currentMat[,i], currentMat[,j]))
                                                    }
                                                }
                                                
                                                similarities[s] <- mean(currentSimilarity)
                                                
                                            }
                                            
                                            self$signatureSimilarities <- similarities
                                            
                                        },
                                        
                                        calculateSimilarity = function() {
                                            
                                            self$calculateSimilarityPerSignature()
                                            return(mean(self$signatureSimilarities))
                                            
                                        },
                                        
                                        cosineSimilarity = function(a, b) {
                                            sum(a * b) / (sqrt(sum(a^2)) * sqrt(sum(b^2)))
                                        }, 
                                        
                                        predict = function() {
                                            
                                            self$computeAverageW()
                                            self$computeAverageH()
                                            
                                            self$predictedMutationMatReduced <- self$Waverage %*% self$Haverage
                                        },
                                        
                                        calculateFrobError = function() {
                                            
                                            self$predict()
                                            
                                            return(norm(self$mutationMatReduced - self$predictedMutationMatReduced, "F"))
                                        }
                                            
                                        
                                        
                                            
                                            
                                        )
                                            
                          )
                             
